   old parse latte markup

   //    NSArray *markups = [markup componentsSeparatedByString:@"@end"];
   //    NSUInteger idx = 0;
   //
   //    if (markups.count > 1)
   //        [self parseStylesheet:markups[idx++]];
   //
   //    markup = markups[idx];
   //
   //    //nodes
   //    LTNode *rootNode, *currentNode, *fatherNode;
   //    rootNode = currentNode = [[LTNode alloc] init];
   //    fatherNode = nil;
   //
   //    //syntax elements counters;
   //    NSInteger tabc = 0, tabo = -1;
   //
   //    for (NSString *l in [markup componentsSeparatedByString:@"\n"]) {
   //
   //        //skip all the empty lines and the comments
   //		NSString *trimmed = [l stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
   //		if ([trimmed isEqualToString:@""] || [trimmed hasPrefix:@"-#"] || [trimmed hasPrefix:@"@layout"]) continue;
   //
   //        //tab counts
   //        tabc = 0;
   //		for (int i = 0; i < l.length; i++)
   //            if ([l characterAtIndex:i] == '\t') tabc++;
   //			else break;
   //
   //        //invalid indentation
   //		if (tabc >  tabo + 1) goto parse_err;
   //
   //		//nested element
   //		if (tabc == tabo + 1)
   //            fatherNode = currentNode;
   //
   //		if (tabc < tabo)
   //			for (NSInteger i = 0; i < tabo-tabc; i++)
   //				fatherNode = fatherNode.father;
   //
   //		tabo = tabc;
   //
   //        //text can be put as nested element
   //		if (![trimmed hasPrefix:@"%"]) {
   //            NSString *text = [NSString stringWithFormat:@"%@\n%@", fatherNode.data[@"text"], l];
   //            fatherNode.data[@"text"] = text;
   //
   //            continue;
   //        }
   //
   //        //update the nodes hierarchy
   //        currentNode = [[LTNode alloc] init];
   //        currentNode.father = fatherNode;
   //
   //        if (fatherNode) [fatherNode.children addObject:currentNode];
   //
   //        //node content
   //		NSError *error = nil;
   //		NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"%([a-zA-z0-9]*)(\.[a-zA-z0-9]*)(\#[a-zA-z0-9]*)*\\{(.*)\\}"
   //																			   options:NSRegularExpressionCaseInsensitive
   //																				 error:&error];
   //        if (error) goto parse_err;
   //
   //        //iterating all the matches for the current line
   //        for (NSTextCheckingResult *match in [regex matchesInString:l options:0 range:NSMakeRange(0, l.length)]) {
   //
   //            NSString *latteIsa = [l substringWithRange:[match rangeAtIndex:1]];
   //
   //			NSUInteger index = 2;
   //			NSString *latteClass = nil;
   //			if (match.numberOfRanges > index &&  [[l substringWithRange:[match rangeAtIndex:index]] hasPrefix:@"."])
   //				latteClass = [l substringWithRange:[match rangeAtIndex:index++]];
   //
   //			NSString *latteId = nil;
   //			if (match.numberOfRanges > index &&  [[l substringWithRange:[match rangeAtIndex:index]] hasPrefix:@"#"])
   //				latteId = [l substringWithRange:[match rangeAtIndex:index++]];
   //
   //			NSString *json = nil;
   //			if (match.numberOfRanges > index)
   //				json = [l substringWithRange:[match rangeAtIndex:index]];
   //
   //            NSMutableDictionary *data = [NSMutableDictionary dictionary];
   //
   //
   //            //get the values from the stylesheet
   //            [data addEntriesFromDictionary:self.sharedStyleSheetCache[latteClass]];
   //            [data addEntriesFromDictionary:self.sharedStyleSheetCache[[NSString stringWithFormat:@"%@%@", latteClass, latteId]]];
   //
   //            //and the values defined in the layout
   //            [data addEntriesFromDictionary:[[NSString stringWithFormat:@"{%@}",json] mutableObjectFromJSONStringWithParseOptions:JKParseOptionComments]];
   //
   //            currentNode.data = data;
   //
   //            if (nil != latteClass)
   //                currentNode.data[kLTTagStyle] = latteClass;
   //
   //			if (nil != latteId)
   //                currentNode.data[kLTTagId] = latteId;
   //            
   //            if (nil != latteIsa)
   //                currentNode.data[kLTTagIsa] = latteIsa;
   //            
   //            else goto parse_err;
   //        }
   //    }
   //    
   //    return rootNode;
   //    
   //    //something went wrong
   //parse_err:
   //    NSLog(@"The markup is not latte compliant.");
   //    return nil;


old parse stylesheet code

//    //clear the cache
//    [self.sharedStyleSheetCache removeAllObjects];
//    
//    @try {
//        for (NSString *l in [markup componentsSeparatedByString:@"\n"]) {
//            
//            //skip all the empty lines and the comments
//            NSString *trimmed = [l stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
//            if ([trimmed isEqualToString:@""] || [trimmed hasPrefix:@"-#"] || [trimmed hasPrefix:kLTTagStylesheet]) continue;
//            
//            NSArray *comps = [trimmed componentsSeparatedByString:@"{"];
//            
//            NSString *selector = comps[0];
//            NSDictionary *values = [[NSString stringWithFormat:@"{%@", [comps lastObject]] mutableObjectFromJSONStringWithParseOptions:JKParseOptionComments];
//            
//            self.sharedStyleSheetCache[selector] = values;
//        }
//    }
//    
//    @catch (NSException *exception) {
//        NSLog(@"Corrupted stylesheet data");
//    }